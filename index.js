const zbase32 = require ('zbase32');
const secp = require("noble-secp256k1");
const sjcl = require('sjcl');

/**
 * Algorithm according to https://twitter.com/rusty_twit/status/1182102005914800128
 * zbase32(SigRec(SHA256(SHA256("Lightning Signed Message:" + msg))))
 */

// Message generated by lightning-cli signmessage test or lncli signmessage --msg test
// Pubkey 02ac77f9f7397a64861b573c9e8b8652ce2e67a05150fd166831e9fc167670dfd8


const signedMessageZbase32 = 'rdq7e66b8gb1x4c8qs383tmi9uo76jdraqbfj8ic7xd1gxyhztfwgdhqhumfehc4dxbed7e5ycf4u6wm9fedfoukz9uqk471okwocw31';

const signedMessage = zbase32.decode(signedMessageZbase32);


const recoveryId = signedMessage[0] - 31;
const signature = signedMessage.slice(1, 65);

function bufToBn(buf) {
    var hex = [];
    u8 = Uint8Array.from(buf);
  
    u8.forEach(function (i) {
      var h = i.toString(16);
      if (h.length % 2) { h = '0' + h; }
      hex.push(h);
    });
  
    return BigInt('0x' + hex.join(''));
  }

  function dec2hex(str){ // .toString(16) only works up to 2^53
    var dec = str.toString().split(''), sum = [], hex = [], i, s
    while(dec.length){
        s = 1 * dec.shift()
        for(i = 0; s || i < sum.length; i++){
            s += (sum[i] || 0) * 10
            sum[i] = s % 16
            s = (s - sum[i]) / 16
        }
    }
    while(sum.length){
        hex.push(sum.pop().toString(16))
    }
    return hex.join('')
}

const rBytes = signature.slice(0,32);
const sBytes = signature.slice(32, 64);
const r = bufToBn(rBytes);
const s = bufToBn(sBytes)


const sig = new secp.Signature(r, s);
console.log(sig, 'valid:', sig.assertValidity());



const userMessage = 'test';
const message = "Lightning Signed Message:" + userMessage;

const dsha256 = sjcl.hash.sha256.hash(sjcl.hash.sha256.hash(message));
const msgHash = sjcl.codec.hex.fromBits(dsha256)
console.log('dsha256', dsha256, msgHash);

const point = secp.Point.fromSignature(msgHash, sig, recoveryId);
console.log('nodeId:', point.toHex(true))



