const zbase32 = require ('zbase32');
const secp = require("noble-secp256k1");
const sjcl = require('sjcl');

/**
 * Algorithm according to https://twitter.com/rusty_twit/status/1182102005914800128
 * zbase32(SigRec(SHA256(SHA256("Lightning Signed Message:" + msg))))
 */

// Message generated by lightning-cli signmessage test or lncli signmessage --msg test
// Pubkey 02ac77f9f7397a64861b573c9e8b8652ce2e67a05150fd166831e9fc167670dfd8


const signedMessageZbase32 = 'rdq7e66b8gb1x4c8qs383tmi9uo76jdraqbfj8ic7xd1gxyhztfwgdhqhumfehc4dxbed7e5ycf4u6wm9fedfoukz9uqk471okwocw31';

const signedMessage = zbase32.decode(signedMessageZbase32);
console.log('signedMessage', signedMessage);
/**
 * Output:
 * signedMessage Uint8Array(65) [
   32, 105, 119, 116,  41,  52, 171,  77,  62,  60,  52,
  117, 236, 226,  67,  57, 233, 181, 106, 235, 154, 255,
  124, 190,  37,   8, 184, 206, 147,  46, 133, 110,  65,
   29,   3,  53,  34, 211, 175, 107, 243, 202, 187, 117,
  172,   3,  24, 153, 152, 196, 254, 117,  21,  41,  52,
  186,  41, 106, 143,  90, 187, 166,  29,  86, 111
]
 */

const recoveryId = signedMessage[0] - 31;
const signature = signedMessage.slice(1, 65);

console.log('signature', signature, 'recoveryId', recoveryId);
/**
 * Output:
 * signature Uint8Array(64) [
  105, 119, 116,  41,  52, 171,  77,  62,  60,  52, 117,
  236, 226,  67,  57, 233, 181, 106, 235, 154, 255, 124,
  190,  37,   8, 184, 206, 147,  46, 133, 110,  65,  29,
    3,  53,  34, 211, 175, 107, 243, 202, 187, 117, 172,
    3,  24, 153, 152, 196, 254, 117,  21,  41,  52, 186,
   41, 106, 143,  90, 187, 166,  29,  86, 111
] 
recoveryId 1
 */

function bufToBn(buf) {
    var hex = [];
    u8 = Uint8Array.from(buf);
  
    u8.forEach(function (i) {
      var h = i.toString(16);
      if (h.length % 2) { h = '0' + h; }
      hex.push(h);
    });
  
    return BigInt('0x' + hex.join(''));
  }

  function dec2hex(str){ // .toString(16) only works up to 2^53
    var dec = str.toString().split(''), sum = [], hex = [], i, s
    while(dec.length){
        s = 1 * dec.shift()
        for(i = 0; s || i < sum.length; i++){
            s += (sum[i] || 0) * 10
            sum[i] = s % 16
            s = (s - sum[i]) / 16
        }
    }
    while(sum.length){
        hex.push(sum.pop().toString(16))
    }
    return hex.join('')
}

const rBytes = signature.slice(0,32);
const sBytes = signature.slice(32, 64);
const r = bufToBn(rBytes);
const s = bufToBn(sBytes)


const sig = new secp.Signature(r, s);
console.log(sig, 'valid:', sig.assertValidity());



const userMessage = 'test';
const message = "Lightning Signed Message:" + userMessage;

const dsha256 = sjcl.hash.sha256.hash(sjcl.hash.sha256.hash(message));
const msgHash = sjcl.codec.hex.fromBits(dsha256)
console.log('dsha256', dsha256, msgHash);

const point = secp.Point.fromSignature(msgHash, sig, recoveryId);
console.log(point, point.assertValidity())
console.log('nodeId:', typeof msgHash === 'string' ? point.toHex() : point.toRawBytes());
console.log(point.toHex(true))


// secp.Signature.fromHex(signature); // throws Error('Signature.fromHex: Invalid signature')
// secp.recoverPublicKey throws the same error

